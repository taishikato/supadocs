name: Reindex Documentation

on:
  push:
    paths:
      - "**/*.md"
      - "**/*.mdx"
      - ".github/workflows/reindex.yml"
      - "supabase/functions/reindex/**"
  pull_request:
    paths:
      - "**/*.md"
      - "**/*.mdx"
      - ".github/workflows/reindex.yml"
      - "supabase/functions/reindex/**"
  workflow_dispatch:
    inputs:
      force_full_sync:
        description: "Reindex all docs when triggered manually"
        type: boolean
        default: false

jobs:
  reindex:
    name: Trigger Supabase Edge Function
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect changed Markdown files
        id: changes
        uses: tj-actions/changed-files@v45
        with:
          files: |
            **/*.md
            **/*.mdx

      - name: Compute raw base URL
        id: meta
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            REF="${{ github.event.pull_request.head.sha }}"
          else
            REF="${{ github.sha }}"
          fi
          echo "base_url=https://raw.githubusercontent.com/${{ github.repository }}/$REF/" >> "$GITHUB_OUTPUT"

      - name: Skip when no docs changed
        if: |
          steps.changes.outputs.any_changed != 'true' &&
          ! (github.event_name == 'workflow_dispatch' && github.event.inputs.force_full_sync == 'true')
        run: echo "No Markdown changes detected; skipping reindex call."

      - name: Call reindex Edge Function
        if: |
          steps.changes.outputs.any_changed == 'true' ||
          (github.event_name == 'workflow_dispatch' && github.event.inputs.force_full_sync == 'true')
        uses: actions/github-script@v7
        env:
          EDGE_FUNCTION_URL: ${{ secrets.SUPABASE_REINDEX_FUNCTION_URL }}
          EDGE_FUNCTION_SECRET: ${{ secrets.EDGE_FUNCTION_REINDEX_SECRET }}
          BASE_URL: ${{ steps.meta.outputs.base_url }}
          ADDED_FILES: ${{ steps.changes.outputs.added_files }}
          MODIFIED_FILES: ${{ steps.changes.outputs.modified_files }}
          DELETED_FILES: ${{ steps.changes.outputs.deleted_files }}
        with:
          script: |
            const { execSync } = require("node:child_process");

            if (!process.env.EDGE_FUNCTION_URL) {
              core.setFailed("SUPABASE_REINDEX_FUNCTION_URL secret is not configured.");
              return;
            }

            if (!process.env.EDGE_FUNCTION_SECRET) {
              core.setFailed("EDGE_FUNCTION_REINDEX_SECRET secret is not configured.");
              return;
            }

            if (!process.env.BASE_URL) {
              core.setFailed("BASE_URL is not available from the metadata step.");
              return;
            }

            const parseList = (value) => {
              if (!value) return [];
              return value
                .split(/\r?\n/)
                .map((item) => item.trim())
                .filter(Boolean);
            };

            const deduplicate = (items) => [...new Set(items)];

            const forceFullSync =
              context.eventName === "workflow_dispatch" &&
              (context.payload.inputs?.force_full_sync ?? "false") === "true";

            let changedPaths = [];
            let deletedPaths = [];

            if (forceFullSync) {
              core.info("force_full_sync requested; collecting all Markdown/MDX files.");
              const output = execSync(
                "git ls-tree --full-tree -r HEAD --name-only",
                { encoding: "utf8" },
              );
              changedPaths = output
                .split(/\r?\n/)
                .map((line) => line.trim())
                .filter(
                  (line) =>
                    line &&
                    (line.endsWith(".md") || line.endsWith(".mdx")),
                );
            } else {
              const added = parseList(process.env.ADDED_FILES);
              const modified = parseList(process.env.MODIFIED_FILES);
              const deleted = parseList(process.env.DELETED_FILES);
              changedPaths = deduplicate([...added, ...modified]);
              deletedPaths = deduplicate(deleted);
            }

            if (changedPaths.length === 0 && deletedPaths.length === 0) {
              core.info("Nothing to reindex after evaluating inputs; exiting early.");
              return;
            }

            const payload = {
              repoRawBaseUrl: process.env.BASE_URL,
              changedPaths,
              deletedPaths,
            };

            core.info(
              `Calling edge function with ${changedPaths.length} changed and ${deletedPaths.length} deleted paths.`,
            );

            try {
              const response = await fetch(process.env.EDGE_FUNCTION_URL, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "x-edge-secret": process.env.EDGE_FUNCTION_SECRET,
                },
                body: JSON.stringify(payload),
              });

              const body = await response.text();
              core.info(`Edge function responded with status ${response.status}`);
              if (body) {
                core.info(body);
              }

              if (!response.ok) {
                core.setFailed(`Edge function failed with status ${response.status}`);
              }
            } catch (error) {
              core.setFailed(`Edge function request failed: ${error instanceof Error ? error.message : String(error)}`);
            }
